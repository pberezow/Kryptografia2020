# Zadanie 1

### Treść
Construct an algorithm which predicts next bits of linear congruencial generator, use this algorithm to construct a distinguisher (statistical test) which can distinguish output generated by an instance of LCG from a random string.

### Rozwiązanie
Implementacja rozwiązania znajduje się w pliku `lcg.py`.

LCG generuje kolejne liczby pseudolosowe w następujący sposób:
$$X_{n+1} = (aX_n + c) \mod{m}$$
, gdzie $X_i$ jest i-tą wygenerowaną liczbą. Do odgadnięcia kolejnych wartości zwracanych przez generator musimy wyznaczyć wartości parametrów $a$, $c$ oraz $m$ algorytmu. Do ich wyznaczenia będziemy potrzebować kilku kolejnych liczb wygenerowanych przez LCG.

Zaczynamy od wyznaczenia parametru $m$. Przy wyznaczaniu wartości modulo korzystamy z faktu, że jeśli mamy kilka wielokrotności jakiejś liczby, to z bardzo dużym prawdopodobieństwem ich największy wspólny dzielnik będzie równy tej liczbie.

Zdefiniujmy teraz ciąg $T(n) = X_{n+1} - X_n$

$$t_0 = X_1 - X_0$$
$$t_1 = X_2 - X_1 = (aX_1 + c) - (aX_0 + c) = a(X_1 - X_0) = at_0 \mod{m}$$
$$\vdots$$
$$t_n = X_{n+1} - X_n = (aX_{n+1} + c) - (aX_n + c) = a(X_{n+1} - X_n) = at_{n-1} \mod{m}$$

Możemy zauważyć, że:
$$t_2 t_0 - t_1 t_1 = (aat_0 t_0) - (at_0 at_0) = 0 \mod{m}$$
$$\vdots$$
$$t_{n+2} t_n - t_{n+1} t_{n+1} = 0 \mod{m}$$

Korzystając z tego równania możemy wyznaczyć $m$.

Parametr $a$ wyznaczamy korzystając z wyliczonego wcześniej $m$:
$$X_2 - X_1 = aX_1 - aX_0 \mod{m}$$
$$X_2 - X_1 = a(X_1 - X_0) \mod{m}$$
$$a = \frac{X_2 - X_1}{X_1 - X_0} \mod{m}$$ 

Następnie znając $a$ oraz $m$ możemy wyznaczyć $c$:
$$X_1 = (aX_0 + c) \mod{m}$$
$$c = (X_1 - aX_0) \mod{m}$$

Po wyliczeniu wszystkich parametrów generatora, jesteśmy w stanie generować takie same liczby.

# Zadanie 2

### Treść
Your goal is the same as in Problem 1, but here,the generator is glibc's random().

### Rozwiązanie
Implementacja rozwiązania znajduje się w pliku `glibc.py`.

Algorytm używany przez glibc random() wygląda następująco:

1. $r_0 = \text{seed}$
2. $r_i = (16807 * r_{i-1}) \mod{(2^{31}-1)}$    (for i = 1...30)
3. $r_i = r_{i-31}$    (for i = 31...33)
4. $r_i = (r_{i-3} + r_{i-31}) \mod{2^{32}}$    (for i ≥ 34)

Pierwsze 343 wygenerowane w ten sposób wartości są odrzucane, a i-tą liczbą zwróconą przez random() jest:
$$o_i = r_{i+343} >> 1$$
(ucinamy najmniej znaczący bit wygenerowanej liczby)

Możemy zauważyć, że:
$o_i = o_{i-31} + o_{i-3} \mod{2^{31}} \text{ lub } o_i = o_{i-31} + o_{i-3} + 1 \mod{2^{31}}$, (for i ≥ 31)
Przy czym druga sytuacja będzie miała miejsce tylko jeśli $o_{i-31}$ i $o_{i-3}$ miały wartość ostatniego bitu równą 1, w każdym innym przypadku zachodzić będzie pierwsza równość.

Znając 31 kolejnych liczb wygenerowanych przez random() możemy więc wyznaczyć kolejną z prawdopodobieństwem 75%. W pozostałych 25% wyznaczona liczba będzie o 1 mniejsza od faktycznej wartości zwróconej przez generator.
